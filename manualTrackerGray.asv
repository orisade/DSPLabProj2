%%Signal Processing Laboratory - Project 2 - task 9
%Ori Sade - 318262128
%Liav Cohen - 209454693
clc;
clear;
close all;
%% user inputs
filename = 'Harry.avi';
outFilename = 'output.avi';
Nbins=16;
RGB = true;

%% Initialization
videoFileReader = vision.VideoFileReader(which(filename));
%reading a single image from video - for start
if RGB
    videoFrame = double(step(videoFileReader));
    videoFrameFit = colorHist(videoFrame,Nbins);
    lastVideoFrame = 
else
    videoFrame = double(rgb2gray(step(videoFileReader)));
    lastVideoFrame = videoFrame;
end
figure; imshow(videoFrame);
selcetedBox = drawrectangle();
BBox = selcetedBox.Position;
close;
%opening a video object for playing the video
videoInfo = info(videoFileReader); % information about the source video
videoPlayer = vision.VideoPlayer('Position',[300 300 videoInfo.VideoSize+30]);
%BAR INFO
numberOfFrames = videoInfo.VideoFrameRate*mmfileinfo(filename).Duration;
%creating an object for writing a video to it
v = VideoWriter(outFilename);
open(v);
%writing first frame to video
videoOut = insertObjectAnnotation(videoFrame,'rectangle',BBox,'object');
writeVideo(v,videoOut);
minError = inf;
%the process of tracking the selected image
frameNumber=0;

%% algorithem
waitBarObject = waitbar(frameNumber,'Please wait...');
while ~isDone(videoFileReader) %untill video is finished
    waitbar(frameNumber/numberOfFrames,waitBarObject, sprintf('Please wait... Tracking in progress (%.3f%%)',frameNumber/numberOfFrames*100));
    frameNumber=frameNumber+1;
%for i=1:20
    % Extract the next video frame
    if RGB
        videoFrameDisplay = double(step(videoFileReader));
        videoFrame = colorHist(videoFrameDisplay,Nbins);
    else
        videoFrameDisplay = double(rgb2gray(step(videoFileReader)));
        videoFrame = videoFrameDisplay;
    end
    %tracking the object
    [BBox, minError,searchBBox] = serachingAlgo(lastVideoFrame,videoFrame, BBox,Nbins);
    %save last frame
    lastVideoFrame = videoFrame;
    % Insert a bounding box around the object being tracked
    videoOut = insertObjectAnnotation(videoFrameDisplay,'rectangle',BBox,'object');
    videoOut = insertObjectAnnotation(videoOut,'rectangle',searchBBox,'searchErea');
    % Display the annotated video frame using the video player object
    step(videoPlayer, videoOut);
    % Write frame to output video
    writeVideo(v,videoOut);
end
disp(~isDone(videoFileReader));
close(waitBarObject);
%%
% Release resources
release(videoFileReader);
release(videoPlayer);
% Close output video
close(v);
command = strcat('"C:\\Program Files (x86)\\Windows Media Player\\wmplayer.exe" "', which(outFilename), '"');
system(command);

%% searching function
function [newBBox, newMinError,searchBBox] = serachingAlgo(lastVideoFrame, videoFrame, BBox,Nbins)
	newBBox = BBox;
	newMinError = inf;
    bound = 20;
	%initialize histogram
	x = int16(BBox(1));
	y = int16(BBox(2));
	w = int16(BBox(3));
	h = int16(BBox(4));
	%ROICenter = [x+w/2 y+h/2];
    %% Searching algorithem
    Object = lastVideoFrame(y:y+h-1, x:x+w-1);
    [y_max, x_max] = size(videoFrame);
    x_max = min([x+bound, x_max-w-1]);
    x_min = max([1,x-bound]);
    y_max = min([y+bound, y_max-h-1]);
    y_min = max([1,y-bound]);
    searchBBox = [x_min, y_min, x_max-x_min+w, y_max-y_min+h];
    if x_min >= x_max || y_min >= y_max
        disp('min is bigger than max!');
        return
    end
	%seraching in a radius of 'bound' around the selected image (BBox)
   errorFunction(Object,0,"loadHist",Nbins);
    for x=x_min:x_max 
		for y=y_min:y_max
                tmpImage = videoFrame(y:y+h-1, x:x+w-1);
			error = errorFunction(0, tmpImage, "",Nbins);
			if error < newMinError
				newMinError = error;
				newBBox = [x y w h];
			end
		end
    end
end	%end function


function newI=colorHist(I,Nbins)
        maxPixel = Nbins*Nbins^0+Nbins*Nbins^1+Nbins*Nbins^2;
        newI = zeros(size(I,1),size(I,2));
        for x=1:size(I,1)
            for y=1:size(I,2)
                R = int16(I(x,y,1)*Nbins); G = int16(I(x,y,2)*Nbins); B = int16(I(x,y,3)*Nbins);
                newI(x,y) = R+G*Nbins+B*Nbins^2;
                newI(x,y) = newI(x,y)/maxPixel;
            end
        end
end






